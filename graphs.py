# -*- coding: utf-8 -*-
"""
Created on Thu Sep  2 14:41:15 2021

@author: RGHS

Generate graphs for various procedures and find intersection of lines.
"""

import numpy as np
import matplotlib.pyplot as plt
import warnings

#%% Line intersect
# Find the intersection of two straight lines by specifying two points on each
# Method from Norbu Tsering on Stack Overflow
# https://stackoverflow.com/questions/3252194/numpy-and-line-intersections/42727584#42727584

def get_intersect(a1, a2, b1, b2):
    """ 
    Returns the point of intersection of the lines passing through a2,a1 and b2,b1.
    a1: [x, y] a point on the first line
    a2: [x, y] another point on the first line
    b1: [x, y] a point on the second line
    b2: [x, y] another point on the second line
    """
    s = np.vstack([a1,a2,b1,b2])        # s for stacked
    h = np.hstack((s, np.ones((4, 1)))) # h for homogeneous
    l1 = np.cross(h[0], h[1])           # get first line
    l2 = np.cross(h[2], h[3])           # get second line
    x, y, z = np.cross(l1, l2)          # point of intersection
    if z == 0:                          # lines are parallel
        return (float('inf'), float('inf'))
    
    int_x = x/z
    int_y = y/z
    return int_x, int_y

def get_y_val(x_series,y_series,x_unknown):
    '''
    Uses get_intersect to get the Y value of a desired x point.
    '''
    x_series = np.asarray(x_series)
    y_series = np.asarray(y_series)
    
    lower = np.max(np.where(x_series <= x_unknown))
    upper = np.max(np.where(x_series >= x_unknown))
    
    a1 = [x_unknown, np.min(y_series)]
    a2 = [x_unknown, np.max(y_series)]
    b1 = [x_series[lower], y_series[lower]]
    b2 = [x_series[upper], y_series[upper]]
    
    _, intersect_y = get_intersect(a1, a2, b1, b2)
    
    return intersect_y

#%% Useful graphs in sedimentology
def lerouxEAD():
    '''
    Generate axes for plotting the Effective Angular Deviation graph from
    Le Roux (1994).

    Returns
    -------
    EAD_x : np.ndarray
        Array of 0:100 for plotting x-axis of graph.
    EAD_y : np.ndarray
        Array of corresponding values of effective angular deviation for plotting
        y-axis.

    '''
    EAD_x = np.arange(0,101,1)
    EAD_y = np.zeros(101)
    
    eq6 = np.where(EAD_x <= 85)
    eq7 = np.where((EAD_x > 85) & (EAD_x < 98))
    eq8 = np.where(EAD_x >= 98)
    
    EAD_y[eq6] = 5e-8*EAD_x[eq6]**4 - 9e-5*EAD_x[eq6]**3 + 1.07e-2*EAD_x[eq6]**2 - 1.7402*EAD_x[eq6] + 179.95
    EAD_y[eq7] = -2.7e-3*(100 - EAD_x[eq7])**4 + 9.53e-2*(100 - EAD_x[eq7])**3 - 1.23*(100 - EAD_x[eq7])**2 + 9.3963*(100 - EAD_x[eq7]) + 5.9
    EAD_y[eq8] = 1.2183*(100 - EAD_x[eq8])**3 - 5.8723*(100 - EAD_x[eq8])**2 + 14.654*(100 - EAD_x[eq8]) + 5
    
    return EAD_x, EAD_y

def cmp(author = 1):
    '''
    Generates axes of initiation of motion graphs based on van Rijn (1984).

    Parameters
    ----------
    author : int, optional
        Specifies which curve to generate. Options are as follows:
            - 1: Van Rijn, 1984
            - 2: Shields
            - 3: Engelund
            - 4: Bagnold
        The default is 1.

    Returns
    -------
    cmp_x : np.ndarray
        Points on x-axis of selected graph.
    cmp_y : np.ndarray
        Points on y-axis of selected graph.

    '''
    x_base = np.array([1,2,4,6,8,10,20,40,60,80,100,200,400,600,800,1000])
    if(author == 1): # Van Rijn
        cmp_x = x_base[1:16]
        cmp_y = np.array([0.2, 0.1, 0.08, 0.077, 0.08, 0.1, 0.15, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2])
    elif(author == 2):  # Shields
        cmp_x = x_base
        cmp_y = np.array([0.2, 0.1, 0.06, 0.04, 0.035, 0.03, 0.03, 0.04, 0.045, 0.05, 0.055, 0.055, 0.055, 0.055, 0.055, 0.055])
    elif(author == 3):  # Engelund
        cmp_x = x_base[5:16]
        cmp_y = np.array([0.035, 0.06, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08])
    elif(author == 4):  # Bagnold
        cmp_x = x_base[2:16]
        cmp_y = np.array([0.15, 0.3, 0.4, 0.6, 1, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2])
    
    return cmp_x, cmp_y

def carling():
    '''
    Generate the dune stability field from Carling, 1999. Returns x and y
    for upper and lower boundaries of field

    Returns
    -------
    lower_x : list
    lower_y : list
    upper_x : list
    upper_y : list
    
    '''
    upper_x = [0.00001151,0.00001243,0.00001362,0.00001545,0.00001803,0.00002074,0.00002403,0.00002689,0.00003051,0.00003461,0.00003955,0.0000455,0.00005236,0.00006152,0.00007229,0.00009241,0.00010339,0.00012064,0.00014077,0.00017132,0.00020274,0.00025198,0.00030453,0.00038927,0.00046064,0.0005413,0.00066808,0.00079058,0.0009225,0.00110707,0.0012213,0.00139543,0.00165128,0.00184742,0.00198166,0.00218615,0.00236152,0.00249783,0.00271719,0.00289427,0.00299758,0.00310458,0.00342494,0.00391324,0.00447115,0.00514456,0.00617385,0.00715371,0.00805975,0.00889143,0.00987799,0.0112074,0.01316963,0.01442705,0.01648391,0.01844181,0.02107105,0.02373974,0.02829029,0.03142927,0.03565912,0.03989458]
    upper_y = [0.66967476,0.70855272,0.75499477,0.82168679,0.90697585,0.98015454,1.04439871,1.10503127,1.16918385,1.22836524,1.29054225,1.36546467,1.42449736,1.4756362,1.51786596,1.59469683,1.60598565,1.64033386,1.64033386,1.64033386,1.61735439,1.57235668,1.51786596,1.42449736,1.34633584,1.28147075,1.17746047,1.08189217,0.98709303,0.86327868,0.79321086,0.71356855,0.59820143,0.53060023,0.48070431,0.43550044,0.39734038,0.35997578,0.32612483,0.29754864,0.27924551,0.26767328,0.26579175,0.26767328,0.26767328,0.26767328,0.26956813,0.27533355,0.27924551,0.28321305,0.2892703,0.29965498,0.31705145,0.32612483,0.33545787,0.33545787,0.34022408,0.34022408,0.33783257,0.33783257,0.34263251,0.34263251]
    
    lower_x = [0.00001167,0.00001333,0.00001492,0.00001692,0.0000192,0.00002103,0.00002472,0.00002804,0.00003094,0.0000361,0.00004096,0.00004582,0.00005163,0.00005695,0.00006599,0.00007593,0.00008615,0.00009438,0.00010708,0.00011896,0.00013497,0.00014995,0.00017374,0.00020132,0.00022841,0.00025198,0.00027411,0.0003024,0.0003336,0.00036036,0.00040317,0.00043857,0.00047709,0.0005413,0.00059298,0.00067278,0.00075799,0.00088448,0.00100351,0.00117921,0.00131927,0.0014251,0.00159437,0.00192683,0.00229618,0.00266061,0.00308288,0.0035472,0.00459838,0.00555724,0.00643924,0.00783674,0.00876756,0.00974038,0.01112906,0.01262684,0.01536723,0.0174354,0.02048804,0.02493453,0.02909533,0.03232363,0.03641749,0.04219739,0.04787644]
    lower_y = [0.11644168,0.11644168,0.11726597,0.11726597,0.11726597,0.11644168,0.11481045,0.11400342,0.11161621,0.11161621,0.109279,0.1077481,0.10623866,0.10401405,0.10255691,0.09900275,0.09692966,0.09357052,0.08969286,0.08537155,0.08183366,0.07844238,0.07361715,0.06812087,0.06438311,0.05999798,0.05630732,0.05173715,0.04654248,0.04461371,0.04216578,0.03985216,0.0387434,0.03793213,0.03713784,0.03687679,0.03687679,0.03687679,0.03687679,0.03687679,0.03713784,0.03687679,0.03661757,0.03687679,0.03713784,0.03740073,0.03793213,0.03820065,0.04041839,0.04306761,0.04524759,0.04959311,0.05284369,0.05591153,0.05999798,0.06348116,0.06908874,0.07361715,0.07899768,0.08658451,0.09032779,0.09357052,0.09624832,0.10040939,0.10183602]
    return lower_x, lower_y, upper_x, upper_y

def ccsm4(model):
    if model == '12.7wc': 
        pal127wc_x = [87.488,83.883,81.481,78.422,74.927,70.34,66.845,64.005,59.417,56.141,54.175,52.427,50.898,49.369,47.403,46.092,44.563,43.034,41.723,40.413,39.102,37.573,35.825,34.733,32.985,31.238,29.272,27.524,25.34,24.466,21.845,18.786,16.383,14.636,12.451,10.704,8.956,6.117,3.932,2.184,0.655,-1.092,-2.403,-4.369,-6.335,-8.301,-10.485,-12.888,-14.636,-16.383,-18.568,-19.879,-21.408,-23.155,-24.466,-26.214,-27.087,-28.617,-29.709,-31.019,-32.112,-32.767,-34.078,-35.17,-36.917,-37.791,-38.665,-39.757,-40.85,-42.379,-43.252,-44.126,-45.218,-46.092,-46.966,-48.714,-50.024,-51.117,-52.209,-53.738,-55.049,-56.578,-58.325,-60.073,-61.602,-64.005,-66.408,-69.466,-71.432,-73.835,-77.549,-80.17,-83.01,-84.757,-85.631,-87.269,]
        pal127wc_y = [13.576,13.515,13.394,13.394,13.333,13.333,13.636,14.061,14.97,16.303,17.091,17.758,18.788,19.576,20.727,21.576,22.364,23.152,24.061,25.091,25.939,26.788,27.636,28.424,29.273,30,30.606,31.576,32.424,32.667,33.03,33.394,33.636,34,34.242,34.364,34.303,34.121,33.939,33.697,33.636,33.879,34.121,34.242,34.364,34.364,34.303,34.121,34,33.818,33.455,33.152,32.909,32.364,32,31.455,30.909,30.364,29.879,29.333,28.909,28.545,27.879,27.03,26.242,25.758,25.152,24.485,23.758,22.97,22.424,21.818,21.333,20.667,20,19.03,18.606,17.697,17.212,16.545,15.879,15.03,14.364,13.879,12.97,12.303,11.697,11.091,10.545,9.939,9.576,9.394,9.333,9.879,10.303,10.97,]
        return pal127wc_x, pal127wc_y
    elif model == '12.7':
        pal127_x = [87.269,84.976,80.607,78.422,74.709,71.214,67.282,64.66,62.039,60.073,58.325,56.578,54.393,53.301,51.772,50.898,49.806,48.277,46.966,45.655,44.782,43.471,42.16,41.286,39.976,38.883,37.354,36.262,34.733,32.549,31.238,29.709,27.961,26.65,24.903,22.718,20.097,17.476,14.854,12.015,9.612,7.209,5.461,3.714,1.748,0.218,-1.311,-2.84,-5.024,-6.553,-8.519,-10.267,-11.796,-15.073,-17.039,-19.223,-21.189,-22.5,-24.029,-25.995,-27.087,-28.398,-29.49,-30.364,-31.456,-32.549,-33.204,-34.078,-35.388,-36.262,-37.791,-38.665,-39.539,-40.413,-41.505,-42.16,-43.034,-43.689,-44.563,-46.092,-47.403,-48.277,-49.15,-50.243,-51.117,-52.209,-53.301,-54.83,-55.922,-57.015,-58.544,-60.073,-61.165,-62.694,-64.005,-65.971,]
        pal127_y = [8.788,8.727,8.545,8.242,8.121,8.061,8.061,8.424,8.97,9.636,10.303,10.909,11.697,12.424,13.03,13.697,14.303,15.455,16.121,16.909,17.697,18.606,19.455,20.303,21.212,21.879,22.97,23.636,24.485,25.394,26.182,26.909,27.576,28.182,28.909,29.455,29.818,30.182,30.303,30.667,30.97,30.97,30.788,30.364,30,29.818,30.182,30.485,30.788,30.97,30.97,30.97,30.727,30.485,30.121,29.818,29.394,28.97,28.485,27.939,27.212,26.606,26.061,25.636,25.03,24.303,23.758,23.212,22.303,21.758,20.909,20.242,19.576,18.788,18.121,17.576,16.97,16.364,15.455,14.545,13.818,13.273,12.606,11.939,11.333,10.727,9.939,9.455,8.97,8.485,7.818,7.212,6.788,6.182,5.818,5.152,]
        return pal127_x, pal127_y
    elif model == '4':
        pal4_x = [87.488,86.068,84.539,81.917,79.078,74.709,71.869,68.592,65.752,64.005,61.165,58.762,56.796,54.83,53.083,51.335,49.587,47.84,46.966,46.092,44.782,43.908,42.816,41.505,40.631,39.539,38.01,36.262,34.515,32.767,31.238,29.053,27.961,26.214,24.903,22.282,18.568,15.291,12.888,9.83,6.99,4.587,2.621,0.874,-1.311,-3.058,-5.024,-6.99,-10.049,-12.67,-15.728,-18.131,-20.752,-22.718,-24.684,-26.214,-28.398,-31.019,-31.675,-32.767,-33.641,-34.951,-35.825,-37.136,-38.01,-38.883,-39.976,-40.85,-41.942,-42.597,-44.345,-45.437,-46.311,-47.621,-48.932,-50.024,-51.335,-52.864,-54.612,-56.359,-58.544,-59.854,-61.165,-62.694,-65.316,-67.5,-69.684,-72.524,-75.801,-78.641,-82.354,-84.102,-85.194,-86.833,]
        pal4_y = [5.333,5.03,4.727,4.364,4,3.879,4,4.303,4.545,4.909,5.333,5.879,6.424,7.091,7.758,8.545,9.455,10.303,10.848,11.697,12.303,13.273,14,14.667,15.394,16.667,17.818,18.788,20,21.091,22.182,23.091,23.758,24.606,25.152,25.939,26.606,26.97,27.273,27.636,27.697,27.273,26.667,26.424,26.667,27.152,27.515,27.818,27.758,27.455,27.03,26.545,26.182,25.636,24.909,23.939,22.909,21.394,20.727,20.061,19.394,18.545,18,16.97,16.242,15.636,14.727,13.879,13.212,12.182,11.212,10.303,9.455,8.667,8,7.333,6.606,5.697,4.909,4.182,3.273,2.667,2.121,1.455,0.848,0.061,-0.545,-0.909,-1.212,-1.455,-1.455,-0.848,0,0.848,]
        return pal4_x, pal4_y
    else:
        raise Exception('Incorrect "model" parameter provided! Only "12.7wc","12.7" and "4" are accepted.')

#%% Stock graph plotting

def plot_leroux(silent = True):
    '''
    Plots the Le Roux (1994) Effective Angular Deviation graph.

    Returns
    -------
    fig : matplotlib figure
        Plot of EAD vs consistency ratio.

    '''
    fig = plt.figure(figsize = (10,10))
    x,y = lerouxEAD()
    plt.plot(x,y)
    plt.xlim(0,100)
    plt.xticks(np.arange(0,120,20))
    plt.xlabel('Consistency ratio')
    plt.ylim(0, 180)
    plt.yticks(np.arange(0,210,30))
    plt.ylabel('Effective angular deviation / degrees')
    
    if silent is True:
        plt.close()
    
    return fig

#%% Custom graph plotting

def windrose(x, b_int = 10, silent = True):
    '''
    Generates windroses of directional (most commonly paleoflow) data.

    Parameters
    ----------
    x : array-like
        List of directional measurements.
    b_int : float, optional
        Interval by which measurements are binned. The default is 10.
        (Note: numbers greater than 10 produce rather ugly graphs)

    Returns
    -------
    fig : matplotlib figure
        Windrose of plotted figure.

    '''
    if(b_int > 10):
        warnings.warn('Bin sizes greater than 10 produce strange looking bars. You have been warned.')
    bins = np.arange(0,360+b_int,b_int)
    binned = np.histogram(x, bins)[0]
    
    xmax = 2 * np.pi
    x_coords = np.linspace(0, xmax, len(binned), endpoint=False)
    width = xmax/len(bins)
    
    fig = plt.figure(figsize = (10,10))
    ax = fig.add_subplot(111, polar = True)
    ax.bar(x_coords, binned, width = width, align = 'edge')
    ax.set_theta_direction(-1)
    ax.set_theta_zero_location("N")
    
    if silent is True:
        plt.close()
    
    return fig